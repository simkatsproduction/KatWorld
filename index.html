<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KatWorld - Destruction Simulator v1.1</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* --- Base Styles --- */
        * {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            overflow: hidden;
            font-family: 'Press Start 2P', cursive;
            background: #222;
            color: white;
            touch-action: manipulation;
        }

        /* --- Screens --- */
        .screen {
            position: absolute; width: 100vw; height: 100vh;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center; text-align: center;
        }
        #game-container, #loading-screen { display: none; }

        /* --- Home Screen --- */
        .title {
            font-size: clamp(1.8rem, 5vw, 2.5rem); color: #FF6B6B;
            text-shadow: 4px 4px 0 #4ECDC4; margin: 2rem 1rem; line-height: 1.4;
        }
        .pixel-btn {
            padding: 15px 30px; margin: 10px; background: #4ECDC4; color: white;
            border: none; font-family: inherit; font-size: 1rem; cursor: pointer;
            box-shadow: 5px 5px 0 #FF6B6B; transition: all 0.1s ease-out; text-transform: uppercase;
        }
        .pixel-btn:hover, .pixel-btn:focus {
            transform: translate(2px, 2px); box-shadow: 3px 3px 0 #FF6B6B;
            background: #3DBEB5; outline: none;
        }
        #credits {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            font-size: 0.7rem; line-height: 1.6; opacity: 0.8; width: 90%;
        }

        /* --- Loading Screen --- */
        #loading-bar-container { display: flex; flex-direction: column; align-items: center; margin: 30px 0; }
        #loading-bar {
            width: 300px; max-width: 80vw; height: 30px; border: 4px solid white; background-color: #333;
        }
        #loading-progress { height: 100%; width: 0%; background: #4ECDC4; transition: width 0.2s linear; }
        #loading-text { font-size: 0.8rem; min-height: 20px; margin-top: 10px; }

        /* --- Game Screen --- */
        #game-container { background-color: #222; }
        #game-canvas { display: block; background: #87CEEB; border: 2px solid #111; }
        #game-ui {
            position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.75); /* Slightly less transparent */
            padding: 10px 15px; color: white; font-size: 0.8rem; border: 3px solid white; z-index: 10;
            line-height: 1.5; /* Added line height */
        }
        #game-ui div { margin-bottom: 8px; } /* Increased spacing */
        #game-ui div:last-child { margin-bottom: 0; }
        #tools {
            position: absolute; bottom: 15px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 5px; background: rgba(0,0,0,0.75);
            padding: 8px; border: 3px solid white; z-index: 10; flex-wrap: wrap; justify-content: center;
            max-width: 95vw; /* Prevent excessive width */
        }
        .tool-btn {
            padding: 8px 10px; background: #555; color: white;
            border: 2px solid #777; cursor: pointer; font-family: inherit;
            font-size: 0.65rem; transition: background-color 0.1s, border-color 0.1s, transform 0.1s; /* Added transform */
            text-transform: uppercase;
            position: relative; /* For potential future icons/badges */
        }
        .tool-btn span { display: block; font-size: 0.5rem; margin-top: 2px; color: #ccc; } /* Keybind hint */
        .tool-btn:hover { background-color: #666; border-color: #999; }
        /* Improved Active State */
        .tool-btn.active {
             background: #FF6B6B; border: 3px solid #fff; color: #fff;
             transform: scale(1.05); /* Make it slightly bigger */
             box-shadow: 0 0 8px rgba(255, 107, 107, 0.7);
        }
        .tool-btn.active:hover { background: #E05A5A; }

    </style>
</head>
<body>
    <div id="home-screen" class="screen">
        <h1 class="title">KATWORLD<br>DESTRUCTION<br>SIMULATOR</h1>
        <button class="pixel-btn" id="start-btn">Start Game (Demo)</button>
        <div id="credits">
            CREATED BY SIMKAT<br>
            PIXEL PHYSICS ENGINE v1.3 <br>
            Â© <span id="current-year">2025</span> ALL RIGHTS RESERVED
        </div>
    </div>

    <div id="loading-screen" class="screen">
        <h1 class="title">LOADING KATWORLD</h1>
        <div id="loading-bar-container">
            <div id="loading-bar">
                <div id="loading-progress"></div>
            </div>
            <div id="loading-text">Generating terrain...</div>
        </div>
    </div>

    <div id="game-container" class="screen">
        <canvas id="game-canvas"></canvas>
        <div id="game-ui">
            <div>TOOL: <span id="current-tool-ui">BOMB</span></div>
            <div id="selected-block-ui" style="display: none;">BLOCK: <span id="current-block-name">DIRT</span></div> 
            <div id="mouse-coords">X: -- Y: --</div>
            <div id="fps">FPS: --</div>
        </div>
        <div id="tools">
            <button class="tool-btn active" id="bomb-btn" data-tool="bomb">BOMB<span>[1]</span></button>
            <button class="tool-btn" id="block-btn" data-tool="block">BLOCK<span>[2] ([/])</span></button> 
            <button class="tool-btn" id="water-btn" data-tool="water">WATER<span>[3]</span></button>
            <button class="tool-btn" id="destroy-btn" data-tool="destroy">DESTROY<span>[4]</span></button>
            <button class="tool-btn" id="sand-btn" data-tool="sand">SAND<span>[5]</span></button>
            <button class="tool-btn" id="glass-btn" data-tool="glass">GLASS<span>[6]</span></button>
            <button class="tool-btn" id="ignite-btn" data-tool="ignite">IGNITE<span>[7]</span></button>
            <button class="tool-btn" id="picker-btn" data-tool="picker">PICKER<span>[8]</span></button>
            <button class="tool-btn" id="tnt-btn" data-tool="tnt">TNT<span>[9]</span></button>
            <button class="tool-btn" id="acid-btn" data-tool="acid">ACID<span>[0]</span></button>
        </div>
    </div>

    <script>
        // Set current year in credits
        document.getElementById('current-year').textContent = new Date().getFullYear();

        // =====================
        // SCREEN MANAGEMENT (No changes needed here)
        // =====================
        const homeScreen = document.getElementById('home-screen');
        const loadingScreen = document.getElementById('loading-screen');
        const gameContainer = document.getElementById('game-container');
        const startBtn = document.getElementById('start-btn');
        const loadingProgressBar = document.getElementById('loading-progress');
        const loadingText = document.getElementById('loading-text');
        startBtn.addEventListener('click', showLoadingScreen);
        function showLoadingScreen() {
             homeScreen.style.display = 'none';
             loadingScreen.style.display = 'flex';
             startFakeLoading();
        }
        function showGameScreen() {
            loadingScreen.style.display = 'none';
            gameContainer.style.display = 'flex';
            initGame(); // Initialize the game after loading
        }
        function startFakeLoading() {
            const loadingMessages = [ "Generating terrain...", "Planting trees...", "Pouring water...", "Placing ores...", "Optimizing physics...", "Almost ready...", "Ready!" ]; // Added messages
            let progress = 0; let messageIndex = 0;
            loadingText.textContent = loadingMessages[messageIndex];
            const loadInterval = setInterval(() => {
                progress += Math.random() * 10 + 5; progress = Math.min(progress, 100);
                loadingProgressBar.style.width = `${progress}%`;
                const currentMessageIndex = Math.min(Math.floor(progress / (100 / loadingMessages.length)), loadingMessages.length - 1);
                if(currentMessageIndex > messageIndex) { messageIndex = currentMessageIndex; loadingText.textContent = loadingMessages[messageIndex]; }
                if (progress >= 100) { clearInterval(loadInterval); loadingText.textContent = loadingMessages[loadingMessages.length - 1]; setTimeout(showGameScreen, 600); }
            }, 150); // Slightly faster load simulation
         }

        // =====================
        // GAME ENGINE
        // =====================
        function initGame() {
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            ctx.imageSmoothingEnabled = false; // Keep pixelated rendering sharp

            // --- Constants ---
            const PIXEL_SIZE = 10;
            const WORLD_WIDTH = 100;
            const WORLD_HEIGHT = 60;
            const GRAVITY = 0.05;
            const WATER_SPREAD_CHANCE = 0.5; // Slightly reduced spread chance
            const BASE_SURFACE_LEVEL = Math.floor(WORLD_HEIGHT * 0.6);
            const BEDROCK_DEPTH = 4;
            const WATER_LEVEL = Math.floor(WORLD_HEIGHT * 0.7);
            const TERRAIN_ROUGHNESS = 6;
            const TREE_SPACING = 7; // Adjusted slightly
            const PHYSICS_SUBSTEPS = 3;
            const TNT_FUSE_TIME = 5; // Short fuse for chain reactions
            const TNT_RADIUS = 4; // Explosion radius for TNT
            const ACID_CORROSION_CHANCE = 0.3; // Chance to corrode adjacent blocks
            const ACID_CORROSION_DELAY = 30; // Frames between corrosion attempts

            // --- Canvas Setup ---
            canvas.width = WORLD_WIDTH * PIXEL_SIZE;
            canvas.height = WORLD_HEIGHT * PIXEL_SIZE;

            // --- Block Types (Added TNT, Obsidian, Brick, Plant, Acid) ---
            const BLOCK_TYPES = {
                AIR:        {id: 0, color: 'transparent', name: 'Air'},
                DIRT:       {id: 1, color: '#8B4513', health: 1, name: 'Dirt'},
                GRASS:      {id: 2, color: '#7CFC00', topColor: '#228B22', health: 1, name: 'Grass'},
                STONE:      {id: 3, color: '#808080', health: 3, name: 'Stone'},
                WATER:      {id: 4, color: 'rgba(30, 144, 255, 0.7)', fluid: true, name: 'Water'},
                WOOD:       {id: 5, color: '#A0522D', health: 2, name: 'Wood'},
                LEAF:       {id: 6, color: 'rgba(34, 139, 34, 0.8)', transparent: true, health: 0.5, name: 'Leaf'}, // Lower health
                COAL:       {id: 7, color: '#333', sparkleColor: '#555', health: 2, name: 'Coal'},
                IRON:       {id: 8, color: '#B3B3B3', sparkleColor: '#DDD', health: 4, name: 'Iron'},
                GOLD:       {id: 9, color: '#FFD700', sparkleColor: '#FFFACD', health: 3, name: 'Gold'},
                DIAMOND:    {id: 10, color: '#00FFFF', sparkleColor: '#AFFFFF', health: 5, name: 'Diamond'},
                BEDROCK:    {id: 11, color: '#4A4A4A', health: Infinity, name: 'Bedrock'},
                SAND:       {id: 12, color: '#F4A460', health: 1, gravity: true, name: 'Sand'},
                GLASS:      {id: 13, color: 'rgba(210, 240, 255, 0.6)', transparent: true, health: 0.2, name: 'Glass'}, // Lower health
                TNT:        {id: 14, color: '#FF4500', altColor: '#FFA500', health: 1, explosive: true, name: 'TNT'},
                OBSIDIAN:   {id: 15, color: '#3B1F4A', health: 15, name: 'Obsidian'}, // Strong
                BRICK:      {id: 16, color: '#B22222', altColor: '#8B0000', health: 4, name: 'Brick'},
                PLANT:      {id: 17, color: '#90EE90', transparent: true, health: 0.1, name: 'Plant'}, // Decorative
                ACID:       {id: 18, color: 'rgba(50, 255, 50, 0.7)', fluid: true, corrosive: true, name: 'Acid'} // New acid block
            };
            const BLOCK_ID_MAP = {};
            for (const key in BLOCK_TYPES) { BLOCK_ID_MAP[BLOCK_TYPES[key].id] = BLOCK_TYPES[key]; }

            // --- Placeable Blocks for Cycling ---
            const PLACEABLE_BLOCKS = [
                BLOCK_TYPES.DIRT, BLOCK_TYPES.STONE, BLOCK_TYPES.WOOD, BLOCK_TYPES.SAND, BLOCK_TYPES.GLASS,
                BLOCK_TYPES.TNT, BLOCK_TYPES.OBSIDIAN, BLOCK_TYPES.BRICK, BLOCK_TYPES.PLANT, BLOCK_TYPES.WATER,
                BLOCK_TYPES.ACID // Add acid to placeable blocks
            ];
            let currentPlaceableIndex = 0; // Index for cycling

            // Helper function to check if a block is solid (for physics body collision)
            const isSolid = (block) => block && block !== BLOCK_TYPES.AIR && !block.fluid && !block.transparent && block !== BLOCK_TYPES.PLANT; // Plants are not solid
             // Helper to check if block can be replaced by falling blocks/fluids (Modified for Glass/Leaf collision)
            const isPassable = (block) => !block || block === BLOCK_TYPES.AIR || block.fluid; // Only Air and Fluids are truly passable for sand/water flow

            // --- Game State ---
            let world = [];
            let physicsBodies = [];
            let particles = [];
            let activeTool = 'bomb';
            let selectedBlock = PLACEABLE_BLOCKS[currentPlaceableIndex]; // Start with DIRT
            let mousePos = { x: 0, y: 0, gridX: 0, gridY: 0 };
            let isMouseDown = false;
            let lastFrameTime = 0;
            let frameAccumulator = 0;
            let frameCount = 0;
            let fps = 0;
            let acidCorrosionTimer = 0; // Timer for acid corrosion

            // UI Elements References
            const fpsDisplay = document.getElementById('fps');
            const currentToolUI = document.getElementById('current-tool-ui');
            const selectedBlockUIDiv = document.getElementById('selected-block-ui');
            const selectedBlockNameUI = document.getElementById('current-block-name');
            const mouseCoordsUI = document.getElementById('mouse-coords');

            // --- World Generation (No major changes needed, uses existing blocks) ---
            function generateWorld() {
                console.log("Generating world...");
                world = Array(WORLD_WIDTH).fill(null).map(() => Array(WORLD_HEIGHT).fill(BLOCK_TYPES.AIR));
                const dirtDepth = 3;

                for (let x = 0; x < WORLD_WIDTH; x++) {
                    const surfaceY = Math.floor(BASE_SURFACE_LEVEL + Math.sin(x * 0.1) * TERRAIN_ROUGHNESS);
                    for (let y = 0; y < WORLD_HEIGHT; y++) {
                        if (y >= WORLD_HEIGHT - BEDROCK_DEPTH) {
                            world[x][y] = BLOCK_TYPES.BEDROCK;
                        } else if (y >= surfaceY) {
                            if (y === surfaceY) world[x][y] = BLOCK_TYPES.GRASS;
                             else if (y < surfaceY + dirtDepth) world[x][y] = BLOCK_TYPES.DIRT;
                             else {
                                const depthFactor = (y - surfaceY) / (WORLD_HEIGHT - surfaceY - BEDROCK_DEPTH);
                                const rand = Math.random();
                                if (rand < 0.01 * depthFactor * depthFactor) world[x][y] = BLOCK_TYPES.DIAMOND;
                                else if (rand < 0.02 * depthFactor) world[x][y] = BLOCK_TYPES.GOLD;
                                else if (rand < 0.05 * depthFactor) world[x][y] = BLOCK_TYPES.IRON;
                                else if (rand < 0.10 * depthFactor) world[x][y] = BLOCK_TYPES.COAL;
                                // Add occasional Obsidian deep down
                                else if (rand < 0.01 && depthFactor > 0.7) world[x][y] = BLOCK_TYPES.OBSIDIAN;
                                else world[x][y] = BLOCK_TYPES.STONE;
                             }
                        } else {
                            if (y >= WATER_LEVEL) world[x][y] = BLOCK_TYPES.WATER;
                             else world[x][y] = BLOCK_TYPES.AIR;
                        }
                    }
                     // Add occasional plants on grass
                     if (world[x][surfaceY] === BLOCK_TYPES.GRASS && Math.random() < 0.1) {
                         if (world[x][surfaceY - 1] === BLOCK_TYPES.AIR) {
                            world[x][surfaceY - 1] = BLOCK_TYPES.PLANT;
                         }
                     }
                }
                console.log("Terrain generated.");

                const treeMargin = 10;
                for (let x = treeMargin; x < WORLD_WIDTH - treeMargin; x++) {
                     let groundY = -1;
                     for(let y = 0; y < WORLD_HEIGHT; y++) {
                         // Check if block below is solid enough for tree OR grass/dirt
                         const block = world[x][y];
                         const blockBelow = (y + 1 < WORLD_HEIGHT) ? world[x][y+1] : BLOCK_TYPES.BEDROCK;
                         if (block === BLOCK_TYPES.AIR && (blockBelow === BLOCK_TYPES.GRASS || blockBelow === BLOCK_TYPES.DIRT || isSolid(blockBelow))) {
                             groundY = y;
                             break;
                         }
                     }
                    if (groundY > 0 && groundY < WATER_LEVEL - 5) { // Don't plant trees underwater
                        if (Math.random() < 1 / TREE_SPACING) {
                            generateTree(x, groundY);
                            x += Math.floor(TREE_SPACING / 2);
                        }
                    }
                }
                 console.log("Trees generated.");
                console.log("World generation complete.");
            }

            // --- Tree Generation Helper ---
            function generateTree(x, groundY) {
                const minHeight = 4, maxHeight = 7;
                const height = Math.floor(Math.random() * (maxHeight - minHeight + 1)) + minHeight;
                if (groundY - height <= 0) return;
                for (let dy = 0; dy < height; dy++) {
                    const currentY = groundY - dy;
                    if (currentY >= 0 && currentY < WORLD_HEIGHT) {
                        // Allow replacing plants but not solid blocks
                        if(world[x][currentY] === BLOCK_TYPES.AIR || world[x][currentY] === BLOCK_TYPES.PLANT) {
                            world[x][currentY] = BLOCK_TYPES.WOOD;
                        } else { break; } // Stop if blocked by something solid
                    }
                }
                const leafCenterY = groundY - height + 1; const leafRadius = 2;
                for (let lx = x - leafRadius; lx <= x + leafRadius; lx++) {
                    for (let ly = leafCenterY - leafRadius; ly <= leafCenterY + leafRadius; ly++) {
                        if (lx >= 0 && lx < WORLD_WIDTH && ly >= 0 && ly < WORLD_HEIGHT) {
                            const distSq = (lx - x)**2 + (ly - leafCenterY)**2;
                            // Allow replacing plants/air
                            if (distSq < leafRadius**2 + 1 && (world[lx][ly] === BLOCK_TYPES.AIR || world[lx][ly] === BLOCK_TYPES.PLANT)) {
                                if (Math.random() > 0.2) { world[lx][ly] = BLOCK_TYPES.LEAF; }
                            }
                        }
                    }
                }
             }

            // --- Rendering (Added patterns for TNT, Brick, Acid) ---
            function render() {
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                for (let x = 0; x < WORLD_WIDTH; x++) {
                    for (let y = 0; y < WORLD_HEIGHT; y++) {
                        const block = world[x][y];
                        if (block && block !== BLOCK_TYPES.AIR) {
                            let color = block.color;
                            let skipDefaultFill = false;

                            if (block === BLOCK_TYPES.GRASS) {
                                const blockAbove = (y > 0) ? world[x][y-1] : BLOCK_TYPES.AIR;
                                color = (isPassable(blockAbove) || blockAbove === BLOCK_TYPES.PLANT) ? (block.topColor || block.color) : BLOCK_TYPES.DIRT.color;
                            } else if (block === BLOCK_TYPES.WOOD) {
                                color = ((x + y) % 2 === 0) ? block.color : '#6B4226';
                            } else if (block === BLOCK_TYPES.GLASS) {
                                 ctx.fillStyle = block.color;
                                 ctx.fillRect(x * PIXEL_SIZE, y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
                                 ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)'; // Fainter border
                                 ctx.strokeRect(x * PIXEL_SIZE + 0.5, y * PIXEL_SIZE + 0.5, PIXEL_SIZE - 1, PIXEL_SIZE - 1);
                                 skipDefaultFill = true;
                             } else if (block === BLOCK_TYPES.TNT) {
                                // Simple alternating pattern for TNT
                                ctx.fillStyle = ((x + y) % 2 === 0) ? block.color : block.altColor || block.color;
                                ctx.fillRect(x * PIXEL_SIZE, y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
                                // Add "TNT" text
                                ctx.fillStyle = '#000';
                                ctx.font = '6px "Press Start 2P"';
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                ctx.fillText('TNT', x * PIXEL_SIZE + PIXEL_SIZE/2, y * PIXEL_SIZE + PIXEL_SIZE/2);
                                skipDefaultFill = true;
                            } else if (block === BLOCK_TYPES.BRICK) {
                                // Simple brick pattern look
                                const alt = block.altColor || '#A0522D';
                                ctx.fillStyle = block.color;
                                ctx.fillRect(x * PIXEL_SIZE, y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
                                ctx.fillStyle = alt;
                                // Horizontal lines
                                ctx.fillRect(x * PIXEL_SIZE, y * PIXEL_SIZE + PIXEL_SIZE * 0.8, PIXEL_SIZE, PIXEL_SIZE * 0.15);
                                // Vertical lines (offset rows)
                                if (y % 2 === 0) {
                                    ctx.fillRect(x * PIXEL_SIZE + PIXEL_SIZE * 0.45, y * PIXEL_SIZE, PIXEL_SIZE * 0.1, PIXEL_SIZE * 0.85);
                                } else {
                                     ctx.fillRect(x * PIXEL_SIZE, y * PIXEL_SIZE, PIXEL_SIZE * 0.1, PIXEL_SIZE*0.85);
                                     ctx.fillRect(x * PIXEL_SIZE + PIXEL_SIZE*0.9, y * PIXEL_SIZE, PIXEL_SIZE * 0.1, PIXEL_SIZE*0.85);
                                }
                                skipDefaultFill = true;
                            } else if (block === BLOCK_TYPES.ACID) {
                                // Acid with bubbling effect
                                ctx.fillStyle = block.color;
                                ctx.fillRect(x * PIXEL_SIZE, y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
                                // Bubbles
                                if (Math.random() < 0.05) {
                                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                                    const bubbleSize = Math.random() * 0.2 + 0.1;
                                    ctx.beginPath();
                                    ctx.arc(
                                        x * PIXEL_SIZE + PIXEL_SIZE * Math.random(),
                                        y * PIXEL_SIZE + PIXEL_SIZE * Math.random(),
                                        bubbleSize * PIXEL_SIZE,
                                        0, Math.PI * 2
                                    );
                                    ctx.fill();
                                }
                                skipDefaultFill = true;
                            }

                            if (!skipDefaultFill) {
                                ctx.fillStyle = color;
                                ctx.fillRect(x * PIXEL_SIZE, y * PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
                            }

                            if (block.sparkleColor && Math.random() < 0.005) {
                                particles.push({ x: x + Math.random(), y: y + Math.random(), vx:0, vy:0, color: block.sparkleColor, size: Math.random() * 0.1 + 0.05, life: Math.random() * 20 + 10, type: 'sparkle'});
                             }
                        }
                    }
                }

                particles.forEach(p => {
                     ctx.fillStyle = p.color; const drawX = p.x * PIXEL_SIZE; const drawY = p.y * PIXEL_SIZE; const drawSize = p.size * PIXEL_SIZE;
                     ctx.fillRect(drawX - drawSize / 2, drawY - drawSize / 2, drawSize, drawSize);
                 });

                physicsBodies.forEach(body => {
                     ctx.fillStyle = body.color || '#FF0000';
                     if (body.type === 'tnt_fuse') { // Special rendering for TNT fuse
                         ctx.fillStyle = ['#FFA500', '#FF4500', '#FFD700'][Math.floor(Math.random()*3)];
                         ctx.beginPath(); ctx.arc(body.x * PIXEL_SIZE, body.y * PIXEL_SIZE, (Math.random() * 0.2 + 0.1) * PIXEL_SIZE, 0, Math.PI * 2); ctx.fill();
                     } else {
                         ctx.beginPath(); ctx.arc(body.x * PIXEL_SIZE, body.y * PIXEL_SIZE, body.radius * PIXEL_SIZE, 0, Math.PI * 2); ctx.fill();
                         if (body.type === 'bomb' && body.fuse > 0) {
                             particles.push({ x: body.x + (Math.random()-0.5)*0.2, y: body.y - body.radius + (Math.random()-0.5)*0.2, vx: (Math.random()-0.5)*0.02, vy: -Math.random()*0.05, color: ['#FFA500','#FF4500','#FFD700'][Math.floor(Math.random()*3)], size: Math.random()*0.2+0.1, life: 10+Math.random()*10, type:'fuse' });
                         }
                     }
                 });

                if (mousePos.gridX >= 0 && mousePos.gridX < WORLD_WIDTH && mousePos.gridY >= 0 && mousePos.gridY < WORLD_HEIGHT) {
                     ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; ctx.lineWidth = 1;
                     ctx.strokeRect(mousePos.gridX * PIXEL_SIZE + 0.5, mousePos.gridY * PIXEL_SIZE + 0.5, PIXEL_SIZE - 1, PIXEL_SIZE - 1); // Pixel perfect stroke
                 }
            }

            // --- Physics Update (Water Fix, TNT Fuse, Acid Corrosion) ---
            function updatePhysics(deltaTime) {
                const timeFactor = Math.min(deltaTime * 60, 3); // Factor + limit excessive jump

                // 1. Update Particles
                particles = particles.filter(p => {
                     p.x += p.vx * timeFactor; p.y += p.vy * timeFactor;
                     if(p.type !== 'sparkle' && p.type !== 'fuse') { p.vy += GRAVITY * 0.5 * timeFactor; }
                     p.life -= timeFactor; return p.life > 0;
                 });

                // 2. Update Physics Bodies
                physicsBodies = physicsBodies.filter((body) => {
                    if (body.type === 'tnt_fuse') {
                        body.fuse -= timeFactor;
                        if (body.fuse <= 0) {
                            explode(body.x, body.y, TNT_RADIUS, BLOCK_TYPES.TNT); // TNT specific explosion
                            return false; // Remove fuse
                        }
                        return true; // Keep fuse active
                    }

                    // --- Standard Body Physics (Gravity, Collision) ---
                    body.vy += GRAVITY * timeFactor;
                    let remainingTime = timeFactor;
                    for (let i = 0; i < PHYSICS_SUBSTEPS && remainingTime > 0; i++) {
                         const stepTime = remainingTime / (PHYSICS_SUBSTEPS - i);
                         let stepVx = body.vx * stepTime; let stepVy = body.vy * stepTime;
                         let nextX = body.x + stepVx; let nextY = body.y + stepVy;
                         let collided = false;

                         // Simple Grid Collision Check (using isSolid)
                         const checkPoints = [
                             { x: nextX, y: body.y }, // Horizontal mid
                             { x: body.x, y: nextY }, // Vertical mid
                             { x: nextX, y: nextY }  // Diagonal target
                         ];

                         for (const pt of checkPoints) {
                            const gridX = Math.floor(pt.x);
                            const gridY = Math.floor(pt.y);
                            if (gridX >= 0 && gridX < WORLD_WIDTH && gridY >= 0 && gridY < WORLD_HEIGHT) {
                                const block = world[gridX][gridY];
                                if (isSolid(block)) {
                                    collided = true;
                                    // More refined bounce based on impact side could be added
                                    // Simplified bounce:
                                    const dx = nextX - gridX - 0.5;
                                    const dy = nextY - gridY - 0.5;

                                    if (Math.abs(dx) > Math.abs(dy)) { // Horizontal collision likely
                                        body.vx *= -0.4; // Bounce horizontal
                                        nextX = body.x; // Stop x-move for step
                                    } else { // Vertical collision likely
                                        body.vy *= -0.3; // Bounce vertical
                                        nextY = body.y; // Stop y-move for step
                                         body.vx *= 0.8; // Friction
                                    }
                                    break; // Stop checking points on collision
                                }
                            }
                         }

                         body.x = nextX; body.y = nextY; // Update position for the substep

                         if (collided) {
                              body.vx *= 0.95; body.vy *= 0.95; // Dampen slightly
                              // Optional: break substeps early on collision
                         }
                         remainingTime -= stepTime;
                    }
                    // --- End Sub-step ---

                    if (body.type === 'bomb') {
                        body.fuse -= timeFactor;
                        if (body.fuse <= 0) {
                            explode(body.x, body.y, body.radius * 5, BLOCK_TYPES.BOMB); // Pass bomb type
                            return false;
                        }
                    }
                    return body.y < WORLD_HEIGHT + 20 && body.x > -20 && body.x < WORLD_WIDTH + 20; // Keep if within bounds
                });


                 // 3. Block Physics (Water & Sand & Acid)
                 let worldCopy = world.map(arr => arr.slice());
                 const sweepLeftToRight = (frameCount % 2 === 0);

                 for (let y = WORLD_HEIGHT - 2; y >= 0; y--) {
                      for (let xi = 0; xi < WORLD_WIDTH; xi++) {
                          const x = sweepLeftToRight ? xi : WORLD_WIDTH - 1 - xi;
                          const currentBlock = worldCopy[x][y];

                          // --- Sand Physics ---
                          if (currentBlock === BLOCK_TYPES.SAND) {
                               const blockBelow = (y + 1 < WORLD_HEIGHT) ? worldCopy[x][y+1] : BLOCK_TYPES.BEDROCK;
                               if (isPassable(blockBelow)) { // Check below (Passable = Air or Water)
                                    if (world[x][y+1] !== BLOCK_TYPES.SAND) { // Prevent swapping same block type
                                        world[x][y] = blockBelow; // Swap with Air/Water
                                        world[x][y+1] = BLOCK_TYPES.SAND;
                                        continue;
                                    }
                               } else { // Check diagonals if blocked below
                                    const dir = (Math.random() < 0.5) ? -1 : 1;
                                    for (let d = 0; d < 2; d++) { // Check both diagonals
                                        const checkX = x + (d === 0 ? dir : -dir);
                                        if (checkX >= 0 && checkX < WORLD_WIDTH) {
                                            const blockDiag = (y + 1 < WORLD_HEIGHT) ? worldCopy[checkX][y+1] : BLOCK_TYPES.BEDROCK;
                                            // Must be passable below the diagonal space too, or sand piles up weirdly
                                            const blockBelowDiag = (y + 2 < WORLD_HEIGHT) ? worldCopy[checkX][y+2] : BLOCK_TYPES.BEDROCK;
                                            if (isPassable(blockDiag) && isPassable(blockBelowDiag) && world[checkX][y+1] !== BLOCK_TYPES.SAND) {
                                                 world[x][y] = BLOCK_TYPES.AIR; // Sand leaves air
                                                 world[checkX][y+1] = BLOCK_TYPES.SAND;
                                                 // Need 'continue' equivalent for the outer loop if moved
                                                 gotoNextBlockIteration; // Use labeled continue/break or flags if needed
                                            }
                                        }
                                    }
                               }
                          }
                          // --- Water Physics (Improved Spread) ---
                          else if (currentBlock === BLOCK_TYPES.WATER) {
                               const blockBelow = (y + 1 < WORLD_HEIGHT) ? worldCopy[x][y+1] : BLOCK_TYPES.BEDROCK;
                               // Flow down into AIR first priority
                               if (blockBelow === BLOCK_TYPES.AIR) {
                                   if (world[x][y+1] !== BLOCK_TYPES.WATER) { // Ensure not already processed
                                        world[x][y] = BLOCK_TYPES.AIR;
                                        world[x][y+1] = BLOCK_TYPES.WATER;
                                        continue;
                                   }
                               } else { // If blocked below by non-air or already processed, try spreading
                                   const dir = (Math.random() < 0.5) ? -1 : 1;
                                   let spreadDone = false;
                                   // Try spreading into AIR sideways first
                                   for (let d = 0; d < 2; d++) {
                                        const checkX = x + (d === 0 ? dir : -dir);
                                        if (checkX >= 0 && checkX < WORLD_WIDTH && worldCopy[checkX][y] === BLOCK_TYPES.AIR) {
                                            if (world[checkX][y] !== BLOCK_TYPES.WATER && Math.random() < WATER_SPREAD_CHANCE) {
                                                world[x][y] = BLOCK_TYPES.AIR;
                                                world[checkX][y] = BLOCK_TYPES.WATER;
                                                spreadDone = true;
                                                break; // Spread once per frame per block
                                            }
                                        }
                                   }
                                    // Optional: If couldn't spread to AIR, could consider flowing sideways into other water to level out,
                                    // but this can be computationally expensive and might cause oscillations.
                                    // Keeping it simple: prioritize falling, then spreading into AIR.
                                    if(spreadDone) continue;
                               }
                          }
                          // --- Acid Physics (Similar to water but with corrosion) ---
                          else if (currentBlock === BLOCK_TYPES.ACID) {
                               const blockBelow = (y + 1 < WORLD_HEIGHT) ? worldCopy[x][y+1] : BLOCK_TYPES.BEDROCK;
                               // Flow down into AIR first priority
                               if (blockBelow === BLOCK_TYPES.AIR) {
                                   if (world[x][y+1] !== BLOCK_TYPES.ACID) { // Ensure not already processed
                                        world[x][y] = BLOCK_TYPES.AIR;
                                        world[x][y+1] = BLOCK_TYPES.ACID;
                                        continue;
                                   }
                               } else { // If blocked below by non-air or already processed, try spreading
                                   const dir = (Math.random() < 0.5) ? -1 : 1;
                                   let spreadDone = false;
                                   // Try spreading into AIR sideways first
                                   for (let d = 0; d < 2; d++) {
                                        const checkX = x + (d === 0 ? dir : -dir);
                                        if (checkX >= 0 && checkX < WORLD_WIDTH && worldCopy[checkX][y] === BLOCK_TYPES.AIR) {
                                            if (world[checkX][y] !== BLOCK_TYPES.ACID && Math.random() < WATER_SPREAD_CHANCE) {
                                                world[x][y] = BLOCK_TYPES.AIR;
                                                world[checkX][y] = BLOCK_TYPES.ACID;
                                                spreadDone = true;
                                                break; // Spread once per frame per block
                                            }
                                        }
                                   }
                                    if(spreadDone) continue;
                               }
                          }
                          // Labeled continue target (use sparingly)
                          nextBlockIteration:;
                     } // End x loop
                 } // End y loop
                 
                 // 4. Acid Corrosion (Every few frames)
                 acidCorrosionTimer += timeFactor;
                 if (acidCorrosionTimer >= ACID_CORROSION_DELAY) {
                     acidCorrosionTimer = 0;
                     // Find all acid blocks and corrode adjacent blocks
                     for (let x = 0; x < WORLD_WIDTH; x++) {
                         for (let y = 0; y < WORLD_HEIGHT; y++) {
                             if (world[x][y] === BLOCK_TYPES.ACID) {
                                 // Check adjacent blocks (4 directions)
                                 const directions = [
                                     {dx: 1, dy: 0}, {dx: -1, dy: 0},
                                     {dx: 0, dy: 1}, {dx: 0, dy: -1}
                                 ];
                                 
                                 for (const dir of directions) {
                                     const nx = x + dir.dx;
                                     const ny = y + dir.dy;
                                     if (nx >= 0 && nx < WORLD_WIDTH && ny >= 0 && ny < WORLD_HEIGHT) {
                                         const neighbor = world[nx][ny];
                                         // Acid can corrode most blocks except bedrock and obsidian
                                         if (neighbor && neighbor !== BLOCK_TYPES.AIR && 
                                             neighbor !== BLOCK_TYPES.BEDROCK && 
                                             neighbor !== BLOCK_TYPES.OBSIDIAN &&
                                             neighbor !== BLOCK_TYPES.ACID) {
                                             if (Math.random() < ACID_CORROSION_CHANCE) {
                                                 // Create corrosion effect
                                                 particles.push({
                                                     x: nx + 0.5, y: ny + 0.5,
                                                     vx: (Math.random()-0.5)*0.05, vy: -Math.random()*0.05,
                                                     color: '#50FF50',
                                                     size: Math.random()*0.3+0.2,
                                                     life: 20+Math.random()*10,
                                                     type: 'acid'
                                                 });
                                                 // Destroy the block
                                                 world[nx][ny] = BLOCK_TYPES.AIR;
                                             }
                                         }
                                     }
                                 }
                             }
                         }
                     }
                 }
            } // End updatePhysics

            // --- Tool Functions (Handle New Tools & Block Cycling) ---
            function useTool(gridX, gridY) {
                 if (gridX < 0 || gridX >= WORLD_WIDTH || gridY < 0 || gridY >= WORLD_HEIGHT) return;
                 const currentBlock = world[gridX][gridY];

                 switch (activeTool) {
                    case 'bomb':    placeBomb(gridX, gridY); break;
                    case 'block':
                        // Place the selected block type if the target is replaceable
                        if (selectedBlock && (isPassable(currentBlock) || currentBlock === BLOCK_TYPES.PLANT)) {
                            // Don't replace water with solid blocks easily, maybe allow replacing air only?
                            if (selectedBlock !== BLOCK_TYPES.WATER && currentBlock === BLOCK_TYPES.WATER) {
                                // Prevent placing solid blocks directly into water easily
                            } else {
                                world[gridX][gridY] = selectedBlock;
                            }
                        }
                        break;
                    case 'water':   // Keep dedicated water tool? Or merge with block cycling? Keep for now.
                        if(currentBlock === BLOCK_TYPES.AIR || currentBlock === BLOCK_TYPES.PLANT) {
                            world[gridX][gridY] = BLOCK_TYPES.WATER;
                        }
                        break;
                    case 'destroy': destroyBlock(gridX, gridY, 1); break; // Tool destroys 1 block
                    case 'sand':    if(isPassable(currentBlock) || currentBlock === BLOCK_TYPES.PLANT) { world[gridX][gridY] = BLOCK_TYPES.SAND; } break;
                    case 'glass':   if(isPassable(currentBlock) || currentBlock === BLOCK_TYPES.PLANT) { world[gridX][gridY] = BLOCK_TYPES.GLASS; } break;
                    case 'ignite': 
                        if (currentBlock === BLOCK_TYPES.TNT) {
                            triggerTNT(gridX, gridY);
                        }
                        break;
                    case 'picker': 
                        if (currentBlock && currentBlock !== BLOCK_TYPES.AIR && currentBlock !== BLOCK_TYPES.BEDROCK) {
                            // Find the picked block in PLACEABLE_BLOCKS
                            const index = PLACEABLE_BLOCKS.findIndex(b => b.id === currentBlock.id);
                            if (index !== -1) {
                                currentPlaceableIndex = index;
                                selectedBlock = PLACEABLE_BLOCKS[currentPlaceableIndex];
                                setActiveTool('block'); // Switch to block tool
                            }
                        }
                        break;
                    case 'tnt':
                        if(isPassable(currentBlock) || currentBlock === BLOCK_TYPES.PLANT) {
                            world[gridX][gridY] = BLOCK_TYPES.TNT;
                        }
                        break;
                    case 'acid':
                        if(isPassable(currentBlock) || currentBlock === BLOCK_TYPES.PLANT) {
                            world[gridX][gridY] = BLOCK_TYPES.ACID;
                        }
                        break;
                 }
            }

            function placeBomb(gridX, gridY) {
                physicsBodies.push({ x: gridX+0.5, y: gridY+0.5, vx:0, vy:-0.1, radius:0.4, color:'#333', type:'bomb', fuse: 120 }); // Longer fuse
            }

             // --- Unified Explosion Logic ---
             function explode(centerX, centerY, radius, sourceBlock = null) {
                 const explosionRadius = Math.max(1, radius); const explosionRadiusSq = explosionRadius**2;
                 const particleCount = Math.floor(explosionRadius * 15);
                 const explosionColor = sourceBlock === BLOCK_TYPES.TNT ? '#FF4500' : '#FFA500'; // TNT explosions are redder

                 console.log(`Explosion at (${centerX.toFixed(1)}, ${centerY.toFixed(1)}), radius ${explosionRadius.toFixed(1)}`);

                 for (let i = 0; i < particleCount; i++) {
                      const angle = Math.random()*Math.PI*2; const speed = Math.random()*0.2+0.05 + (explosionRadius * 0.02); // Stronger explosion pushes faster
                      const dist = Math.random()*explosionRadius*0.8;
                      particles.push({
                          x: centerX+Math.cos(angle)*dist, y: centerY+Math.sin(angle)*dist,
                          vx: Math.cos(angle)*speed+(Math.random()-0.5)*0.1, vy: Math.sin(angle)*speed+(Math.random()-0.5)*0.1-0.05,
                          color: [explosionColor,'#FFA500','#FFD700','#8B4513', '#555'][Math.floor(Math.random()*5)], // Added gray
                          size: Math.random()*0.4+0.2, life: Math.random()*40+20, type:'explosion'
                      });
                  }

                 const startX = Math.max(0, Math.floor(centerX - explosionRadius)); const endX = Math.min(WORLD_WIDTH-1, Math.floor(centerX + explosionRadius));
                 const startY = Math.max(0, Math.floor(centerY - explosionRadius)); const endY = Math.min(WORLD_HEIGHT-1, Math.floor(centerY + explosionRadius));
                 let triggeredTNT = []; // Keep track of TNT triggered in this explosion

                 for (let x = startX; x <= endX; x++) {
                     for (let y = startY; y <= endY; y++) {
                         const dx = x - centerX + 0.5; const dy = y - centerY + 0.5; const distSq = dx*dx + dy*dy;
                         if (distSq <= explosionRadiusSq) {
                             const block = world[x][y];
                             if (block && block !== BLOCK_TYPES.AIR && block !== BLOCK_TYPES.BEDROCK) {
                                const damageFactor = Math.max(0, 1 - (Math.sqrt(distSq) / explosionRadius)); // Linear falloff
                                const blockResistance = (block.health || 1) / 5; // Simple resistance based on health
                                const effectiveDamage = damageFactor / (blockResistance + 0.5); // More health = less likely to break far away

                                if (effectiveDamage > Math.random() * 0.5 + 0.2) { // Random chance + damage check
                                    // Check for TNT first for chain reaction
                                    if (block === BLOCK_TYPES.TNT) {
                                        if (!triggeredTNT.some(tnt => tnt.x === x && tnt.y === y)) { // Avoid double-triggering
                                            triggerTNT(x, y);
                                            triggeredTNT.push({x, y}); // Mark as triggered
                                             world[x][y] = BLOCK_TYPES.AIR; // Clear immediately for fuse entity
                                        }
                                    } else {
                                         // Create Debris / Shatter
                                         createDestructionEffects(x, y, block, effectiveDamage);
                                         world[x][y] = BLOCK_TYPES.AIR; // Destroy block
                                    }
                                }
                             }
                         }
                     }
                 }
            }

            // --- Helper for TNT triggering ---
            function triggerTNT(gridX, gridY) {
                 if (world[gridX][gridY] === BLOCK_TYPES.TNT) {
                     // Spawn fuse entity instead of direct explosion
                     physicsBodies.push({
                         x: gridX + 0.5, y: gridY + 0.5,
                         vx: 0, vy: 0,
                         radius: 0.1, // Small, doesn't need collision
                         color: '#FF0000', // Not really visible
                         type: 'tnt_fuse',
                         fuse: TNT_FUSE_TIME + Math.random() * 2 // Slight random delay
                     });
                      // Clear the TNT block
                      world[gridX][gridY] = BLOCK_TYPES.AIR;
                      // Add ignition particle
                      particles.push({ x: gridX+0.5, y: gridY+0.5, vx:0, vy:-0.05, color:'#FFF', size:0.3, life:TNT_FUSE_TIME, type:'fuse'});
                 }
            }

            // --- Helper for block destruction effects ---
            function createDestructionEffects(x, y, block, damageFactor) {
                const particleCount = block === BLOCK_TYPES.GLASS ? 6 : (block === BLOCK_TYPES.LEAF || block === BLOCK_TYPES.PLANT ? 4 : 3);
                const baseColor = block.color; // Use block's base color
                const isFragile = block === BLOCK_TYPES.GLASS || block === BLOCK_TYPES.LEAF || block === BLOCK_TYPES.PLANT;

                // Particles
                for(let i=0; i<particleCount; i++) {
                    particles.push({
                        x: x + Math.random(), y: y + Math.random(),
                        vx: (Math.random()-0.5)*0.15, vy:(Math.random()-0.5)*0.15 - 0.05,
                        color: baseColor, // Use block color
                        size: Math.random()*0.25+0.1, life: 15+Math.random()*15, type:'break'
                    });
                }

                // Debris Physics Bodies (Less likely for fragile blocks)
                if (!isFragile && !block.fluid && Math.random() < 0.4 * damageFactor) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = (Math.random()*0.3+0.1)*damageFactor;
                    physicsBodies.push({
                        x: x+0.5, y: y+0.5,
                        vx: Math.cos(angle)*speed+(Math.random()-0.5)*0.1, vy: Math.sin(angle)*speed-Math.random()*0.05,
                        radius: Math.random()*0.2+0.1, color: block.color, type:'debris'
                    });
                }
            }

             // --- Block Destruction (Tool Function) ---
            function destroyBlock(gridX, gridY, radius = 1) { // Radius can be > 1 for bigger destroy tool later
                if (gridX < 0 || gridX >= WORLD_WIDTH || gridY < 0 || gridY >= WORLD_HEIGHT) return;

                const startX = Math.max(0, Math.floor(gridX - radius + 1));
                const endX = Math.min(WORLD_WIDTH - 1, Math.floor(gridX + radius -1));
                const startY = Math.max(0, Math.floor(gridY - radius + 1));
                const endY = Math.min(WORLD_HEIGHT - 1, Math.floor(gridY + radius - 1));

                 for (let x = startX; x <= endX; x++) {
                     for (let y = startY; y <= endY; y++) {
                          const block = world[x][y];
                          if (block && block !== BLOCK_TYPES.AIR && block !== BLOCK_TYPES.BEDROCK) {
                               createDestructionEffects(x, y, block, 1.0); // Max damage factor for tool
                               world[x][y] = BLOCK_TYPES.AIR;
                          }
                     }
                 }
             }

            // --- Event Listeners ---
            function updateMousePos(event) {
                const rect = canvas.getBoundingClientRect(); let clientX, clientY;
                 if (event.touches && event.touches.length > 0) { clientX = event.touches[0].clientX; clientY = event.touches[0].clientY; }
                 else { clientX = event.clientX; clientY = event.clientY; }
                mousePos.x = clientX - rect.left; mousePos.y = clientY - rect.top;
                mousePos.gridX = Math.floor(mousePos.x / PIXEL_SIZE); mousePos.gridY = Math.floor(mousePos.y / PIXEL_SIZE);
                // Update UI
                mouseCoordsUI.textContent = `X: ${mousePos.gridX} Y: ${mousePos.gridY}`;
             }
            function handleMouseDown(event) { updateMousePos(event); isMouseDown = true; useTool(mousePos.gridX, mousePos.gridY); }
            function handleMouseUp(event) { isMouseDown = false; }
            function handleMouseMove(event) {
                 updateMousePos(event);
                 // Allow continuous action for relevant tools
                 if (isMouseDown && (activeTool === 'block' || activeTool === 'water' || activeTool === 'destroy' || activeTool === 'sand' || activeTool === 'glass' || activeTool === 'ignite' || activeTool === 'tnt' || activeTool === 'acid')) {
                     useTool(mousePos.gridX, mousePos.gridY);
                 }
             }
            canvas.addEventListener('mousedown', handleMouseDown); canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp); canvas.addEventListener('mousemove', handleMouseMove);
            // Touch Events
            canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleMouseDown(e); }, { passive: false });
            canvas.addEventListener('touchend', (e) => { e.preventDefault(); handleMouseUp(e); }, { passive: false });
            canvas.addEventListener('touchcancel', (e) => { e.preventDefault(); handleMouseUp(e); }, { passive: false });
            canvas.addEventListener('touchmove', (e) => { e.preventDefault(); handleMouseMove(e); }, { passive: false });

            // --- Keybind Handler (Added Block Cycling) ---
            function handleKeyPress(event) {
                 let targetButtonId = null;
                 switch (event.key) {
                     case '1': targetButtonId = 'bomb-btn'; break;
                     case '2': targetButtonId = 'block-btn'; break;
                     case '3': targetButtonId = 'water-btn'; break;
                     case '4': targetButtonId = 'destroy-btn'; break;
                     case '5': targetButtonId = 'sand-btn'; break;
                     case '6': targetButtonId = 'glass-btn'; break;
                     case '7': targetButtonId = 'ignite-btn'; break;
                     case '8': targetButtonId = 'picker-btn'; break;
                     case '9': targetButtonId = 'tnt-btn'; break;
                     case '0': targetButtonId = 'acid-btn'; break;
                     // Block Cycling Keys
                     case '[':
                         if (activeTool === 'block') {
                             cyclePlaceableBlock(-1); // Cycle backward
                         }
                         break;
                     case ']':
                         if (activeTool === 'block') {
                             cyclePlaceableBlock(1); // Cycle forward
                         }
                         break;
                 }
                 if (targetButtonId) {
                     const button = document.getElementById(targetButtonId);
                     if (button) {
                         button.click(); // Simulate a click
                     }
                 }
            }
            window.addEventListener('keydown', handleKeyPress);

            // --- Tool selection logic ---
            const toolButtons = document.querySelectorAll('.tool-btn');
            function setActiveTool(toolName) {
                activeTool = toolName;
                toolButtons.forEach(btn => {
                    if (btn.dataset.tool === toolName) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                });
                updateSelectedBlockUI(); // Update UI based on new tool
            }

            function updateSelectedBlockUI() {
                currentToolUI.textContent = activeTool.toUpperCase();
                if (activeTool === 'block') {
                    selectedBlockNameUI.textContent = selectedBlock.name.toUpperCase();
                    selectedBlockUIDiv.style.display = 'block'; // Show block name
                } else {
                    selectedBlockUIDiv.style.display = 'none'; // Hide block name
                }
            }

             // Add listeners to buttons
            toolButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const tool = button.dataset.tool;
                    // If clicking a specific block button (sand/glass), also update selectedBlock
                    if (tool === 'sand') selectedBlock = BLOCK_TYPES.SAND;
                    else if (tool === 'glass') selectedBlock = BLOCK_TYPES.GLASS;
                    else if (tool === 'tnt') selectedBlock = BLOCK_TYPES.TNT;
                    else if (tool === 'acid') selectedBlock = BLOCK_TYPES.ACID;

                    // Set the active tool state
                    setActiveTool(tool);
                });
            });

            // --- Block Cycling Function ---
            function cyclePlaceableBlock(direction) {
                if (activeTool !== 'block') return; // Only cycle if block tool is active
                currentPlaceableIndex += direction;
                if (currentPlaceableIndex < 0) {
                    currentPlaceableIndex = PLACEABLE_BLOCKS.length - 1; // Wrap around (backward)
                } else if (currentPlaceableIndex >= PLACEABLE_BLOCKS.length) {
                    currentPlaceableIndex = 0; // Wrap around (forward)
                }
                selectedBlock = PLACEABLE_BLOCKS[currentPlaceableIndex];
                updateSelectedBlockUI(); // Update the UI to show the new block
            }

            // --- FPS Counter ---
            function updateFPSDisplay(now) {
                const deltaTime = Math.min((now - lastFrameTime) / 1000, 0.1); // Prevent huge spikes, limit max delta
                lastFrameTime = now; frameAccumulator += deltaTime; frameCount++;
                if (frameAccumulator >= 1) { fps = frameCount; fpsDisplay.textContent = `FPS: ${fps}`; frameAccumulator -= 1; frameCount = 0; }
                return deltaTime;
            }

            // --- Game Loop ---
            function gameLoop(timestamp) {
                const deltaTime = updateFPSDisplay(timestamp);
                updatePhysics(deltaTime);
                render();
                requestAnimationFrame(gameLoop);
            }

            // --- Start the Game ---
            generateWorld();
            setActiveTool('bomb'); // Set initial tool and UI
            lastFrameTime = performance.now();
            requestAnimationFrame(gameLoop);
        } // End initGame
    </script>
</body>
</html><ALOASK-SEPARATE-EDITORS><ALOASK-SEPARATE-EDITORS>
